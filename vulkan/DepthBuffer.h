#ifndef DEPTHBUFFER_H
#define DEPTHBUFFER_H

// When we run this app without depth buffering two square look like drawn over each other.
// There are two ways to solve this problem:
// - Sort all of the draw call by depth from back to front
// - Use depth testing with a depth buffer

// A depth buffer is an additional attachment that store the depth for every position, just like color attachment that stores color values of every position.
// Every time rasterizer produces a fragment, the depth test will check if the new fragment is closer than previous one.
// It is not, then the new fragment is discarded. A fragment that pass the depth test writes its own depth to depth buffer.
// It is possible to manipulate this value from the fragment shader, just like we can manipulate the color output

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.

// A depth attachment is based on an image, just like the color attachment. The difference is that the swap chain will not automatically create depth images for us

// We only need a single depth image, because only one draw operation is running at once.
// The depth image will again require the trifecta of resources: image, memory and image view.
#include "Context.h"
#include "MemoryManager.h"
class DepthBuffer: public MemoryManager
{
public:
    DepthBuffer() = default;

    void init(const VulkanData &vulkanData);
    void cleanUp();
    VkImage image;
    VkDeviceMemory imageMemory;
    VkImageView imageView;

    void createSources();
private:

    bool hasStencilComponent(VkFormat format);
};

#endif // DEPTHBUFFER_H
